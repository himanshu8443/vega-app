name: Nightly Build

on:
  schedule:
    # Runs at 2:00 AM UTC
    - cron: '0 2 * * *'
  # Optional: Allow manual trigger
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to build'
        required: true
        default: 'main'

jobs:
  build-android:
    runs-on: ubuntu-latest
    # Use the nightly environment with the required secrets
    environment: nightly
    # This ensures the workflow only runs on the specified branch for scheduled runs
    if: github.event_name != 'schedule' || github.ref == 'refs/heads/main'
    steps:
      - name: Checkout specific branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || 'main' }}
          fetch-depth: 0
      
      # Get the latest commit info for Discord notification
      - name: Get commit info
        id: commit_info
        run: |
          echo "COMMIT_HASH=$(git rev-parse --short HEAD)" >> $GITHUB_ENV
          echo "COMMIT_MSG=$(git log -1 --pretty=%B)" >> $GITHUB_ENV
          echo "COMMIT_AUTHOR=$(git log -1 --pretty=%an)" >> $GITHUB_ENV
          echo "COMMIT_DATE=$(git log -1 --pretty=%cd --date=format:'%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
          
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18.x'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'
      
      # Decode the keystore from your secret
      - name: Decode keystore
        run: |
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 --decode > android/app/release.keystore
          # Verify the keystore was created properly
          ls -la android/app/release.keystore
      
      # Make gradlew executable
      - name: Make gradlew executable
        run: chmod +x android/gradlew
      
      # Define the build timestamp
      - name: Set build timestamp
        run: |
          echo "BUILD_DATE=$(date -u '+%Y-%m-%d')" >> $GITHUB_ENV
          echo "BUILD_TIME=$(date -u '+%H-%M-%S')" >> $GITHUB_ENV
          echo "Build started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Builder: himanshu8443"
      
      # Build the APKs with DIRECT SIGNING PARAMETERS as requested
      - name: Build Android App with Direct Signing Parameters
        run: |
          cd android
          KEYSTORE_PATH=$(realpath app/release.keystore)
          ./gradlew assembleRelease \
            -Pandroid.injected.signing.store.file=$KEYSTORE_PATH \
            -Pandroid.injected.signing.store.password="${{ secrets.KEYSTORE_PASSWORD }}" \
            -Pandroid.injected.signing.key.alias="${{ secrets.KEY_ALIAS }}" \
            -Pandroid.injected.signing.key.password="${{ secrets.KEY_PASSWORD }}" \
            --stacktrace
      
      # Find and identify the APKs
      - name: Identify APKs
        run: |
          # Get app version from build.gradle
          VERSION=$(grep -m 1 "versionName " android/app/build.gradle | sed 's/.*versionName "\(.*\)".*/\1/')
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
          
          # Create APKs directory
          mkdir -p apks
          
          # Find all APKs and log them
          echo "Finding APKs:"
          find android/app/build/outputs/apk/release -name "*.apk" -not -name "*unsigned*"
          
          # Define variables for each APK type
          UNIVERSAL_APK=$(find android/app/build/outputs/apk/release -name "*universal*.apk" -not -name "*unsigned*" | head -1)
          ARMV7_APK=$(find android/app/build/outputs/apk/release -name "*armeabi-v7a*.apk" -not -name "*unsigned*" | head -1)
          ARMV8_APK=$(find android/app/build/outputs/apk/release -name "*arm64-v8a*.apk" -not -name "*unsigned*" | head -1)
          
          # Set the file paths with clean names
          if [ -f "$UNIVERSAL_APK" ]; then
            UNIVERSAL_APK_NAME="Vega-v${VERSION}-universal-${BUILD_DATE}.apk"
            cp "$UNIVERSAL_APK" "apks/${UNIVERSAL_APK_NAME}"
            echo "UNIVERSAL_APK_NAME=${UNIVERSAL_APK_NAME}" >> $GITHUB_ENV
            echo "UNIVERSAL_APK_FOUND=true" >> $GITHUB_ENV
          else
            echo "Universal APK not found"
            echo "UNIVERSAL_APK_FOUND=false" >> $GITHUB_ENV
          fi
          
          if [ -f "$ARMV7_APK" ]; then
            ARMV7_APK_NAME="Vega-v${VERSION}-armv7-${BUILD_DATE}.apk"
            cp "$ARMV7_APK" "apks/${ARMV7_APK_NAME}"
            echo "ARMV7_APK_NAME=${ARMV7_APK_NAME}" >> $GITHUB_ENV
            echo "ARMV7_APK_FOUND=true" >> $GITHUB_ENV
          else
            echo "ARMv7 APK not found"
            echo "ARMV7_APK_FOUND=false" >> $GITHUB_ENV
          fi
          
          if [ -f "$ARMV8_APK" ]; then
            ARMV8_APK_NAME="Vega-v${VERSION}-armv8-${BUILD_DATE}.apk"
            cp "$ARMV8_APK" "apks/${ARMV8_APK_NAME}"
            echo "ARMV8_APK_NAME=${ARMV8_APK_NAME}" >> $GITHUB_ENV
            echo "ARMV8_APK_FOUND=true" >> $GITHUB_ENV
          else
            echo "ARMv8 APK not found"
            echo "ARMV8_APK_FOUND=false" >> $GITHUB_ENV
          fi
          
          echo "APKs prepared for upload:"
          ls -la apks/
      
      # Install Appwrite CLI
      - name: Install Appwrite CLI
        run: |
          curl -sL https://appwrite.io/cli/install.sh | bash
          appwrite --version
      
      # Upload APKs to Appwrite storage with fixed permissions
      - name: Upload APKs to Appwrite
        run: |
          # Configure Appwrite CLI with correct parameters
          appwrite client --endpoint "${{ secrets.APPWRITE_ENDPOINT }}" --project-id "${{ secrets.APPWRITE_PROJECT_ID }}" --key "${{ secrets.APPWRITE_API_KEY }}"
          
          # Function to upload file and extract file ID
          upload_to_appwrite() {
            local FILE_PATH=$1
            local FILE_NAME=$(basename "$FILE_PATH")
            
            echo "Uploading $FILE_NAME to Appwrite bucket ${{ secrets.APPWRITE_BUCKET_ID }}..."
            
            # Upload file with correct permission format (fixed)
            RESPONSE=$(appwrite storage create-file \
              --bucket-id "${{ secrets.APPWRITE_BUCKET_ID }}" \
              --file-id "unique()" \
              --file "$FILE_PATH" \
              --permissions "read")
            
            # Extract file ID from the response
            # First check if the response contains an ID pattern
            if echo "$RESPONSE" | grep -q '"$id":'; then
              # Extract file ID
              FILE_ID=$(echo "$RESPONSE" | grep -o '"$id":"[^"]*"' | cut -d':' -f2 | tr -d '"')
              
              if [ -n "$FILE_ID" ]; then
                echo "Uploaded $FILE_NAME with ID: $FILE_ID"
                
                # Generate download URL
                DOWNLOAD_URL="${{ secrets.APPWRITE_ENDPOINT }}/storage/buckets/${{ secrets.APPWRITE_BUCKET_ID }}/files/$FILE_ID/download"
                
                # Create a variable with a unique name for each file
                CLEAN_NAME=$(echo "$FILE_NAME" | sed 's/[^a-zA-Z0-9]/_/g')
                echo "${CLEAN_NAME}_URL=$DOWNLOAD_URL" >> $GITHUB_ENV
                
                # Create a simpler variable name for the Discord notification
                if [[ "$FILE_NAME" == *"universal"* ]]; then
                  echo "UNIVERSAL_DOWNLOAD_URL=$DOWNLOAD_URL" >> $GITHUB_ENV
                elif [[ "$FILE_NAME" == *"armv7"* ]]; then
                  echo "ARMV7_DOWNLOAD_URL=$DOWNLOAD_URL" >> $GITHUB_ENV
                elif [[ "$FILE_NAME" == *"armv8"* ]]; then
                  echo "ARMV8_DOWNLOAD_URL=$DOWNLOAD_URL" >> $GITHUB_ENV
                fi
                return 0
              fi
            fi
            
            echo "Failed to upload $FILE_NAME to Appwrite. Response: $RESPONSE"
            return 1
          }
          
          # Upload each APK type if it exists
          if [ "$UNIVERSAL_APK_FOUND" = "true" ]; then
            upload_to_appwrite "apks/$UNIVERSAL_APK_NAME"
          fi
          
          if [ "$ARMV7_APK_FOUND" = "true" ]; then
            upload_to_appwrite "apks/$ARMV7_APK_NAME"
          fi
          
          if [ "$ARMV8_APK_FOUND" = "true" ]; then
            upload_to_appwrite "apks/$ARMV8_APK_NAME"
          fi
      
      # Also upload APKs as GitHub artifacts as backup
      - name: Upload APKs as GitHub artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Vega-v${{ env.APP_VERSION }}-APKs-${{ env.BUILD_DATE }}
          path: apks/*.apk
          if-no-files-found: warn
      
      # Create and run a dedicated Discord notification script with direct download links
      - name: Create Discord notification script
        run: |
          cat > send_discord.sh << 'EOF'
          #!/bin/bash

          # Get environment variables
          REPO_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}"
          WORKFLOW_URL="${REPO_URL}/actions/runs/${GITHUB_RUN_ID}"
          COMMIT_URL="${REPO_URL}/commit/${GITHUB_SHA}"

          # Format the commit message (escape quotes for JSON)
          FORMATTED_COMMIT_MSG=$(echo "$COMMIT_MSG" | head -n 1 | sed 's/"/\\"/g')
          CURRENT_TIMESTAMP=$(date -u --iso-8601=seconds)

          # Check which download links are available and build the download section
          DOWNLOAD_SECTION=""
          
          if [ -n "$UNIVERSAL_DOWNLOAD_URL" ]; then
            DOWNLOAD_SECTION="${DOWNLOAD_SECTION}â€¢ [ðŸ“± **Universal APK**](${UNIVERSAL_DOWNLOAD_URL}) - Works on all devices\n"
          fi
          
          if [ -n "$ARMV7_DOWNLOAD_URL" ]; then
            DOWNLOAD_SECTION="${DOWNLOAD_SECTION}â€¢ [ðŸ“± **ARMv7 APK**](${ARMV7_DOWNLOAD_URL}) - For older Android devices\n"
          fi
          
          if [ -n "$ARMV8_DOWNLOAD_URL" ]; then
            DOWNLOAD_SECTION="${DOWNLOAD_SECTION}â€¢ [ðŸ“± **ARMv8 APK**](${ARMV8_DOWNLOAD_URL}) - For newer Android devices (recommended)\n"
          fi
          
          # If no download links available, use a fallback message
          if [ -z "$DOWNLOAD_SECTION" ]; then
            DOWNLOAD_SECTION="No download links available. Please check the [workflow run](${WORKFLOW_URL}) for more information."
          fi

          # Create the JSON payload
          cat > discord_payload.json << EOJSON
          {
            "embeds": [
              {
                "title": "ðŸŒ™ Vega Nightly Build v${APP_VERSION}",
                "description": "A new nightly build of **Vega App** is ready for testing!",
                "color": 3447003,
                "fields": [
                  {
                    "name": "Version",
                    "value": "v${APP_VERSION} (Build #${GITHUB_RUN_NUMBER})",
                    "inline": true
                  },
                  {
                    "name": "Build Date",
                    "value": "${BUILD_DATE} UTC",
                    "inline": true
                  },
                  {
                    "name": "Latest Commit",
                    "value": "[${COMMIT_HASH}](${COMMIT_URL}) by ${COMMIT_AUTHOR}",
                    "inline": false
                  },
                  {
                    "name": "Commit Message",
                    "value": "${FORMATTED_COMMIT_MSG}",
                    "inline": false
                  },
                  {
                    "name": "Download APKs (Direct Links)",
                    "value": "${DOWNLOAD_SECTION}",
                    "inline": false
                  },
                  {
                    "name": "Which APK should I download?",
                    "value": "â€¢ **Universal**: If you're not sure about your device\nâ€¢ **ARMv8**: For phones from the last ~5 years (smaller file size)\nâ€¢ **ARMv7**: For very old devices only",
                    "inline": false
                  }
                ],
                "footer": {
                  "text": "Built by himanshu8443 â€¢ Vega App"
                },
                "timestamp": "${CURRENT_TIMESTAMP}"
              }
            ]
          }
          EOJSON

          # Send to Discord
          if [ -n "${DISCORD_WEBHOOK}" ]; then
            curl -H "Content-Type: application/json" -d @discord_payload.json "${DISCORD_WEBHOOK}"
            echo "Discord notification sent successfully"
          else
            echo "Discord webhook URL not set, skipping notification"
          fi
          EOF

          chmod +x send_discord.sh
          
      - name: Send Discord notification
        if: success()
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: ./send_discord.sh
